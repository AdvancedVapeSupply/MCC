<!DOCTYPE html>
<html>
<head>
    <title>MCT Viewer</title>
    <style>
        body { 
            margin: 0; 
            position: relative; 
            background: black; 
            overflow: hidden;
        }
        canvas { 
            width: 100%; 
            height: 100%; 
            position: absolute;
            z-index: 2;
            background: transparent;
        }
        #smoke-background {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 100vh;
            border: none;
            pointer-events: none;
            z-index: 1;
            background: black;
            transform: translate(-50%, -50%);
            display: none;  /* Hide smoke by default */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            pointer-events: none;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: block;
            z-index: 3;
        }
        #togglesDiv {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 3;
            display: none;  /* Hide by default */
        }
        #coordsDiv {
            display: none;  /* Hide by default */
        }
        .toggle-container {
            margin-bottom: 10px;
        }
        .toggle-button {
            background: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .toggle-button.active {
            background: #0f0;
            color: #000;
        }
        .intensity-slider {
            width: 100%;
            margin-top: 5px;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/loaders/STLLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/STLLoader.js"
        }
    }
    </script>
</head>
<body>
    <iframe id="smoke-background" src="smoke.html"></iframe>
    <div id="info"></div>
    <div id="togglesDiv"></div>
    <div id="coordsDiv"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
        import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';

        // Define key surface mappings
        const keySurfaces = {
            'f': [19226, 19232, 19229, 19220],  // F key surfaces
            'u': [45966],                       // U key surfaces
            'k': [61737, 61736, 61740, 61739, 61741, 61738],  // K key surfaces (all segments)
            'd': [30100]                        // D key surfaces
        };

        // Define button colors and properties
        const buttonProperties = {
            'f': { 
                color: 0x111111,
                hoverColor: 0x00ff00,
                label: 'F',
            },
            'u': { 
                color: 0x111111,
                hoverColor: 0x00ff00,
                label: 'U'
            },
            'k': { 
                color: 0x111111,
                hoverColor: 0x00ff00,
                label: 'K'
            },
            'd': { 
                color: 0x111111,
                hoverColor: 0x00ff00,
                label: 'D'
            }
        };

        // Create button texture
        function createButtonTexture(label, properties = {}) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fill background with gradient
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            if (properties.backgroundColor) {
                gradient.addColorStop(0, properties.backgroundColor.inner);
                gradient.addColorStop(1, properties.backgroundColor.outer);
            } else {
                gradient.addColorStop(0, '#003300');
                gradient.addColorStop(1, '#001100');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            // Add text
            ctx.fillStyle = properties.glowColor || '#00ff00';
            ctx.font = 'bold 64px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 64, 64);
            
            // Add glow effect
            ctx.shadowColor = properties.glowColor || '#00ff00';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = properties.glowColor || '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeText(label, 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        // Create button material
        function createButtonMaterial(properties) {
            return new THREE.MeshPhongMaterial({
                color: properties.color,
                transparent: false,
                opacity: 1.0,
                emissive: 0x000000,
                specular: 0x222222,
                shininess: 30,
                side: THREE.DoubleSide
            });
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = null;  // Keep background transparent

        // Camera setup
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            premultipliedAlpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        // Create rotating group
        const rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);

        // Create highlight overlays group
        const highlightOverlays = new THREE.Group();
        rotatingGroup.add(highlightOverlays);

        // Basic lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(0, 1, 2);
        scene.add(directionalLight);

        // Create starfield
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 2,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: false
            });

            return new THREE.Points(starGeometry, starMaterial);
        }

        const starfield = createStarfield();
        scene.add(starfield);

        // Load the STL file
        const loader = new STLLoader();
        loader.load('MCT.stl', function(geometry) {
            geometry.center();
            geometry.computeVertexNormals();
            
            const scale = 0.5;
            geometry.scale(scale, scale, scale);
            
            // Create base mesh with glossy black material
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                specular: 0x666666,
                shininess: 100,
                side: THREE.DoubleSide
            });

            // Create base model and store it in the global scope
            window.mctMesh = new THREE.Mesh(geometry, baseMaterial);
            mctMesh.rotation.x = -Math.PI / 2;
            rotatingGroup.add(mctMesh);

            // Log total number of faces for debugging
            const totalFaces = geometry.attributes.position.count / 3;
            console.log('Total faces in model:', totalFaces);

            // Create ring mesh from selected surfaces
            const ringGeometry = new THREE.BufferGeometry();
            const positions = [];
            const normals = [];
            const indices = [];
            let vertexCount = 0;

            const basePositions = geometry.attributes.position.array;
            const baseNormals = geometry.attributes.normal.array;

            // Process each face
            for (let i = 0; i < basePositions.length; i += 9) {
                const faceIndex = Math.floor(i / 9);
                if (surfaceRecording.r.has(faceIndex)) {
                    // Add vertices for this face
                    for (let j = 0; j < 9; j += 3) {
                        positions.push(
                            basePositions[i + j],
                            basePositions[i + j + 1],
                            basePositions[i + j + 2]
                        );
                        normals.push(
                            baseNormals[i + j],
                            baseNormals[i + j + 1],
                            baseNormals[i + j + 2]
                        );
                    }
                    indices.push(vertexCount, vertexCount + 1, vertexCount + 2);
                    vertexCount += 3;
                }
            }

            // Create the ring geometry
            ringGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            ringGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            ringGeometry.setIndex(indices);
            ringGeometry.computeVertexNormals();

            // Create cloudy white material with high translucency
            const ringMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.9,  // Very high transmission
                thickness: 0.2,     // Thinner material
                envMapIntensity: 0.5,
                clearcoat: 0.0,     // Remove clearcoat for better transmission
                transparent: true,
                opacity: 0.3,       // Very transparent
                side: THREE.DoubleSide
            });

            // Create and add ring mesh
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.rotation.x = -Math.PI / 2;
            ringMesh.renderOrder = 1;
            rotatingGroup.add(ringMesh);

            // Create LED lights
            const ledPositions = [
                // Front center left to right (D2-D5)
                { name: 'D2', x: -0.3, y: 0, z: 0.5 },  // Adjusted position for testing
                { name: 'D3', x: -0.1, y: 0, z: 0.5 },
                { name: 'D4', x: 0.1, y: 0, z: 0.5 },
                { name: 'D5', x: 0.3, y: 0, z: 0.5 },
                
                // Right side top to bottom (D6-D9)
                { name: 'D6', x: 0.4, y: 0, z: 0.4 },
                { name: 'D7', x: 0.4, y: 0, z: 0.3 },
                { name: 'D8', x: 0.4, y: 0, z: 0.2 },
                { name: 'D9', x: 0.4, y: 0, z: 0.1 },
                
                // Left side top to bottom (D17-D10)
                { name: 'D17', x: -0.4, y: 0, z: 0.4 },
                { name: 'D16', x: -0.4, y: 0, z: 0.3 },
                { name: 'D15', x: -0.4, y: 0, z: 0.2 },
                { name: 'D14', x: -0.4, y: 0, z: 0.1 },
                { name: 'D13', x: -0.4, y: 0, z: 0 },
                { name: 'D12', x: -0.4, y: 0, z: -0.1 },
                { name: 'D11', x: -0.4, y: 0, z: -0.2 },
                { name: 'D10', x: -0.4, y: 0, z: -0.3 }
            ];

            // Create LED lights group
            const ledGroup = new THREE.Group();
            window.leds = {};  // Store LED references globally

            ledPositions.forEach(pos => {
                const light = new THREE.PointLight(0x000000, 2, 1);  // Increased intensity and reduced distance
                light.position.set(pos.x, pos.y, pos.z);
                
                // Create small sphere to visualize LED position
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                sphere.position.copy(light.position);
                
                // Group light and sphere
                const ledUnit = new THREE.Group();
                ledUnit.add(light);
                ledUnit.add(sphere);
                ledUnit.name = pos.name;
                
                ledGroup.add(ledUnit);
                window.leds[pos.name] = { light, sphere };
            });

            // Add LED group to scene
            rotatingGroup.add(ledGroup);

            // Function to set LED color and intensity
            window.setLED = function(name, color, intensity = 2.0) {
                const led = window.leds[name];
                if (led) {
                    led.light.color.setHex(color);
                    led.light.intensity = intensity;
                    led.sphere.material.color.setHex(color);
                }
            };

            // Test D2 with green
            window.setLED('D2', 0x00ff00);

            // Create environment map from starfield for reflections
            const envMap = createStarfieldEnvMap(renderer, scene, starfield);
            ringMaterial.envMap = envMap;

            // Create button overlays
            Object.entries(keySurfaces).forEach(([key, surfaces]) => {
                console.log(`Creating overlay for ${key} with surfaces:`, surfaces); // Debug output
                const buttonGeometry = new THREE.BufferGeometry();
                const positions = [];
                const normals = [];
                const uvs = [];
                const indices = [];
                let vertexCount = 0;

                const basePositions = geometry.attributes.position.array;
                const baseNormals = geometry.attributes.normal.array;

                for (let i = 0; i < basePositions.length; i += 9) {
                    const faceIndex = Math.floor(i / 9);
                    if (surfaces.includes(faceIndex)) {
                        for (let j = 0; j < 9; j += 3) {
                            positions.push(
                                basePositions[i + j],
                                basePositions[i + j + 1],
                                basePositions[i + j + 2] + 0.1
                            );
                            normals.push(
                                baseNormals[i + j],
                                baseNormals[i + j + 1],
                                baseNormals[i + j + 2]
                            );
                            uvs.push(j === 0 ? 0 : j === 3 ? 1 : 0.5, j === 0 ? 0 : j === 3 ? 0 : 1);
                        }
                        indices.push(vertexCount, vertexCount + 1, vertexCount + 2);
                        vertexCount += 3;
                    }
                }

                if (positions.length > 0) {
                    buttonGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    buttonGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                    buttonGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                    buttonGeometry.setIndex(indices);
                    buttonGeometry.computeVertexNormals();

                    const buttonMaterial = createButtonMaterial(buttonProperties[key]);
                    const buttonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);
                    buttonMesh.rotation.x = -Math.PI / 2;
                    buttonMesh.renderOrder = 1;
                    buttonMesh.userData.key = key;
                    rotatingGroup.add(buttonMesh);
                    
                    highlightOverlays.userData[key] = buttonMesh;
                }
            });
        });

        // Orbit controls setup
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 50;
        orbitControls.maxDistance = 300;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            
            // Rotate starfield slowly
            starfield.rotation.y += 0.0002;
            starfield.rotation.x += 0.0001;

            renderer.render(scene, camera);
        }
        animate();

        // Mouse and raycaster setup for all interactions
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        // Mouse position tracking
        function updateMousePosition(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            return new THREE.Vector3(mouse.x, mouse.y, 0).unproject(camera);
        }

        // Add info display for surface IDs
        const infoDiv = document.getElementById('info');
        infoDiv.style.display = 'none';  // Hide the info div completely

        // Function to find surface ID from face index
        function getSurfaceInfo(faceIndex) {
            for (const [key, surfaces] of Object.entries(keySurfaces)) {
                if (surfaces.includes(faceIndex)) {
                    return `Surface ID: ${faceIndex} (${key.toUpperCase()} key)`;
                }
            }
            return `Surface ID: ${faceIndex}`;
        }

        // Surface recording state
        const surfaceRecording = {
            'r': new Set([
                // Original pairs
                27963, 27962,                    // First pair
                22009, 22010,                    // Second pair
                23201, 23200,                    // Third pair
                
                // 21987-22008 sequence
                21987, 21988, 21989, 21990, 21991, 21992, 21993,
                21994, 21995, 21996, 21997, 21998, 21999, 22000,
                22001, 22002, 22003, 22004, 22005, 22006, 22007, 22008,
                
                // 23202-23223 sequence
                23202, 23203, 23204, 23205, 23206, 23207, 23208, 23209, 23210,
                23211, 23212, 23213, 23214, 23215, 23216, 23217, 23218, 23219,
                23220, 23221, 23222, 23223,
                
                // 26626-26707 sequence
                26626, 26627, 26628, 26629,    // First group
                26631, 26632, 26633, 26634, 26635, 26636,    // Second group
                26637, 26638, 26639, 26640, 26641, 26642, 26643,  // Third group
                26644, 26645, 26646, 26647, 26648, 26649,  // Fourth group
                26650, 26651, 26652, 26653, 26654,    // Fifth group
                26655, 26656, 26657, 26658, 26659,    // Sixth group
                26660, 26661, 26662, 26663, 26664, 26665,  // Seventh group
                26666, 26667, 26668, 26669, 26670,    // Eighth group
                26671, 26672, 26673, 26674, 26675, 26676,  // Ninth group
                26677, 26678, 26679, 26680, 26681, 26682, 26683, 26684,  // Tenth group
                26685, 26686, 26687, 26688, 26689,  // Eleventh group
                26690, 26691, 26692, 26693, 26694, 26695, 26696, 26697, 26698, 26699,  // Twelfth group
                26700, 26701, 26702, 26703, 26704, 26705, 26706, 26707,  // Final group
                
                // Additional surfaces
                82100, 82146,                  // 82xxx group
                25951                          // Single
            ]),
            currentFace: null
        };

        // Function to update the display of recorded surfaces
        function updateSurfaceDisplay() {
            // Empty function - we no longer need to display surface info
        }

        // Function to find key from surface ID
        function findKeyForSurface(faceIndex) {
            for (const [key, surfaces] of Object.entries(keySurfaces)) {
                if (surfaces.includes(faceIndex)) {
                    return key;
                }
            }
            return null;
        }

        // Materials for different states
        const mctMaterial = new THREE.MeshPhongMaterial({
            color: 0x333333,
            specular: 0x444444,
            shininess: 30,
            side: THREE.DoubleSide,
            transparent: false,
            opacity: 1.0
        });

        // Remove old overlay material and functions
        const overlayMaterial = null;
        function createOverlay() { return null; }

        // Track active buttons
        const activeButtons = new Set();

        // Function to highlight button
        function highlightButton(key, highlight) {
            const buttonMesh = highlightOverlays.userData[key];
            if (buttonMesh && buttonMesh.material) {
                if (highlight) {
                    buttonMesh.material.color.setHex(buttonProperties[key].hoverColor);
                    buttonMesh.material.emissive.setHex(buttonProperties[key].hoverColor);
                    buttonMesh.material.emissiveIntensity = 1.0;
                    activeButtons.add(key);
                } else {
                    buttonMesh.material.color.setHex(buttonProperties[key].color);
                    buttonMesh.material.emissive.setHex(0x000000);
                    buttonMesh.material.emissiveIntensity = 0;
                    activeButtons.delete(key);
                }
            }
        }

        // Consolidated keyboard event listeners
        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Handle button keys (f, u, k, d)
            if (keySurfaces[key]) {
                highlightButton(key, true);
            }
            
            // Handle ring surface recording (r)
            if (key === 'r' && surfaceRecording.currentFace !== null) {
                surfaceRecording.r.add(surfaceRecording.currentFace);
                updateSurfaceDisplay();
            }
            
            // Handle coordinates toggle (c)
            if (key === 'c') {
                coordsDiv.style.display = coordsDiv.style.display === 'none' ? 'block' : 'none';
                if (coordsDiv.style.display === 'block') {
                    updateCoordinates();
                }
            }
            
            // Handle toggles panel (t)
            if (key === 't') {
                const togglesDiv = document.getElementById('togglesDiv');
                togglesDiv.style.display = togglesDiv.style.display === 'none' ? 'block' : 'none';
            }
        });

        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (keySurfaces[key]) {
                highlightButton(key, false);
            }
        });

        // Mouse event handlers for button interaction
        window.addEventListener('mousemove', (event) => {
            updateMousePosition(event);
            // First try to intersect with the base model
            const intersects = raycaster.intersectObject(mctMesh);
            if (intersects.length > 0) {
                const faceIndex = Math.floor(intersects[0].faceIndex);
                surfaceRecording.currentFace = faceIndex;
                updateSurfaceDisplay();
                
                // Check if this face belongs to a key
                const key = findKeyForSurface(faceIndex);
                if (key) {
                    // Highlight all surfaces of this key
                    const buttonMesh = highlightOverlays.userData[key];
                    if (buttonMesh && buttonMesh.material) {
                        buttonMesh.material.color.setHex(buttonProperties[key].hoverColor);
                        buttonMesh.material.emissive.setHex(buttonProperties[key].hoverColor);
                        buttonMesh.material.emissiveIntensity = 0.5;
                    }
                }
                
                // Reset other keys
                Object.entries(keySurfaces).forEach(([k, _]) => {
                    if (k !== key) {
                        const mesh = highlightOverlays.userData[k];
                        if (mesh && mesh.material) {
                            mesh.material.color.setHex(buttonProperties[k].color);
                            mesh.material.emissive.setHex(0x000000);
                            mesh.material.emissiveIntensity = 0;
                        }
                    }
                });
            } else {
                // Reset all keys when not hovering over any
                Object.entries(keySurfaces).forEach(([key, _]) => {
                    const mesh = highlightOverlays.userData[key];
                    if (mesh && mesh.material) {
                        mesh.material.color.setHex(buttonProperties[key].color);
                        mesh.material.emissive.setHex(0x000000);
                        mesh.material.emissiveIntensity = 0;
                    }
                });
                surfaceRecording.currentFace = null;
                updateSurfaceDisplay();
            }
        });

        window.addEventListener('mousedown', (event) => {
            updateMousePosition(event);
            const intersects = raycaster.intersectObjects(Object.values(highlightOverlays.userData), true);
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const key = mesh.userData.key;
                if (key) {
                    highlightButton(key, true);
                }
            }
        });

        window.addEventListener('mouseup', (event) => {
            activeButtons.forEach(key => {
                highlightButton(key, false);
            });
        });

        // Create a canvas texture for the 80x160 pixel grid
        const createPixelGridTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 80;
            canvas.height = 160;
            const ctx = canvas.getContext('2d');
            
            // Fill background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 80, 160);
            
            // Draw grid
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 0.5;
            
            // Draw vertical lines
            for (let x = 0; x <= 80; x += 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 160);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= 160; y += 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(80, y);
                ctx.stroke();
            }

            // Add pixel coordinates at corners
            ctx.fillStyle = '#00ff00';
            ctx.font = '8px monospace';
            ctx.fillText('0,0', 2, 8);
            ctx.fillText('80,0', 50, 8);
            ctx.fillText('0,160', 2, 158);
            ctx.fillText('80,160', 50, 158);
            
            return new THREE.CanvasTexture(canvas);
        };

        // Screen rectangle setup
        let screenWidth = 6.2;  // Physical width
        let screenHeight = 11.5;  // Physical height to maintain aspect ratio of 80x160
        const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
        const texture = createPixelGridTexture();
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        
        const screenMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide,
            map: texture
        });

        const screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
        screenMesh.position.set(0.1, 3.2, 9.5);  // Keep existing position
        scene.add(screenMesh);  // Add screen to scene immediately

        // Create coordinates div
        const coordsDiv = document.createElement('div');
        coordsDiv.id = 'coordinates';
        coordsDiv.style.position = 'absolute';
        coordsDiv.style.top = '10px';
        coordsDiv.style.left = '10px';
        coordsDiv.style.color = '#00ff00';
        coordsDiv.style.fontFamily = 'monospace';
        coordsDiv.style.whiteSpace = 'pre';
        coordsDiv.style.background = 'rgba(0,0,0,0.7)';
        coordsDiv.style.padding = '10px';
        coordsDiv.style.borderRadius = '5px';
        coordsDiv.style.zIndex = '1000';
        coordsDiv.style.display = 'none';
        document.body.appendChild(coordsDiv);

        // Update coordinates display
        function updateCoordinates(event) {
            if (coordsDiv.style.display === 'none') return;

            let coordsText = '';
            
            // Add mouse position if event provided
            if (event) {
                const worldPos = updateMousePosition(event);
                coordsText += `Mouse: (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})\n\n`;
            }

            // Add screen position
            coordsText += `Screen: (${screenMesh.position.x.toFixed(2)}, ${screenMesh.position.y.toFixed(2)}, ${screenMesh.position.z.toFixed(2)})\n`;
            coordsText += `Screen Size: ${screenWidth.toFixed(1)} x ${screenHeight.toFixed(1)}\n\n`;

            // Add button overlay positions
            Object.entries(keySurfaces).forEach(([key, _]) => {
                const buttonMesh = highlightOverlays.userData[key];
                if (buttonMesh) {
                    const worldPos = new THREE.Vector3();
                    const worldRot = new THREE.Euler();
                    
                    buttonMesh.getWorldPosition(worldPos);
                    worldRot.setFromRotationMatrix(buttonMesh.matrixWorld);
                    
                    coordsText += `${key.toUpperCase()} Key:\n`;
                    coordsText += `  Pos: (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})\n`;
                    coordsText += `  Rot: (${(worldRot.x * 180/Math.PI).toFixed(1)}°, ${(worldRot.y * 180/Math.PI).toFixed(1)}°, ${(worldRot.z * 180/Math.PI).toFixed(1)}°)\n\n`;
                }
            });

            coordsDiv.innerHTML = coordsText;
        }

        // Add mouse move listener
        window.addEventListener('mousemove', updateCoordinates);

        // Create light controls
        const lightControls = {
            key: createLightControl('Key Light', directionalLight, 12.0),
            lowKey: createLightControl('Low Key', ambientLight, 8.0),
            rim: createLightControl('Rim Light', directionalLight, 8.0),
            left: createLightControl('Left Light', directionalLight, 8.0),
            right: createLightControl('Right Light', directionalLight, 8.0)
        };

        // Add controls to toggles div
        Object.values(lightControls).forEach(control => {
            togglesDiv.appendChild(control);
        });

        // Create coordinates toggle in controls panel
        const coordsControl = document.createElement('div');
        coordsControl.className = 'toggle-container';
        coordsControl.style.borderTop = '1px solid #666';
        coordsControl.style.marginTop = '10px';
        coordsControl.style.paddingTop = '10px';

        const coordsButton = document.createElement('button');
        coordsButton.className = 'toggle-button';  // Start inactive
        coordsButton.textContent = 'Show Coordinates';
        coordsButton.addEventListener('click', () => {
            coordsButton.classList.toggle('active');
            coordsDiv.style.display = coordsButton.classList.contains('active') ? 'block' : 'none';
        });

        coordsControl.appendChild(coordsButton);
        togglesDiv.appendChild(coordsControl);

        // Create environment map from starfield
        function createStarfieldEnvMap(renderer, scene, stars) {
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512);
            const cubeCamera = new THREE.CubeCamera(1, 100000, cubeRenderTarget);
            scene.add(cubeCamera);
            
            // Update the environment map
            function updateEnvMap() {
                if (stars.visible) {
                    // Temporarily hide the model and other objects
                    const visibleObjects = scene.children.filter(obj => obj.visible && obj !== stars);
                    visibleObjects.forEach(obj => obj.visible = false);
                    
                    // Update the environment map
                    cubeCamera.update(renderer, scene);
                    
                    // Restore visibility
                    visibleObjects.forEach(obj => obj.visible = true);
                }
                requestAnimationFrame(updateEnvMap);
            }
            updateEnvMap();
            
            return cubeRenderTarget.texture;
        }

        // Add background effect controls
        const bgControl = document.createElement('div');
        bgControl.className = 'toggle-container';
        bgControl.style.borderTop = '1px solid #666';
        bgControl.style.marginTop = '10px';
        bgControl.style.paddingTop = '10px';

        // Starfield toggle
        const starfieldButton = document.createElement('button');
        starfieldButton.className = 'toggle-button active';  // Start active
        starfieldButton.textContent = 'Starfield';
        starfieldButton.addEventListener('click', () => {
            starfieldButton.classList.toggle('active');
            starfield.visible = starfieldButton.classList.contains('active');
        });

        // Smoke toggle
        const smokeButton = document.createElement('button');
        smokeButton.className = 'toggle-button';  // Start inactive
        smokeButton.textContent = 'Smoke Effect';
        const smokeBackground = document.getElementById('smoke-background');
        smokeButton.addEventListener('click', () => {
            smokeButton.classList.toggle('active');
            smokeBackground.style.display = smokeButton.classList.contains('active') ? 'block' : 'none';
        });

        // Add background controls to toggles div
        bgControl.appendChild(starfieldButton);
        bgControl.appendChild(smokeButton);
        togglesDiv.appendChild(bgControl);

        // Add copy button for ring surfaces
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Ring Surfaces';
        copyButton.style.position = 'absolute';
        copyButton.style.top = '10px';
        copyButton.style.right = '10px';
        copyButton.style.zIndex = '1000';
        copyButton.style.background = '#00ff00';
        copyButton.style.color = '#000000';
        copyButton.style.border = 'none';
        copyButton.style.padding = '5px 10px';
        copyButton.style.cursor = 'pointer';
        copyButton.style.borderRadius = '3px';
        copyButton.addEventListener('click', () => {
            const surfaces = Array.from(surfaceRecording.r).join(', ');
            navigator.clipboard.writeText(surfaces);
        });
        document.body.appendChild(copyButton);

        // Create LED chase animation
        const GREEN = 0x00ff00;
        const OFF = 0x000000;
        const CHASE_SPEED = 100; // ms between steps
        
        // LED sequence for chase effect (in order)
        const chaseSequence = [
            'D2', 'D3', 'D4', 'D5',  // Front
            'D6', 'D7', 'D8', 'D9',  // Right side
            'D10', 'D11', 'D12', 'D13', 'D14', 'D15', 'D16', 'D17'  // Left side (bottom to top)
        ];

        let currentLedIndex = 0;
        let chaseInterval = null;

        // Function to start LED chase
        window.startChase = function() {
            if (chaseInterval) return; // Don't start if already running
            
            // Turn all LEDs off initially
            chaseSequence.forEach(name => {
                setLED(name, OFF, 0);
            });
            
            chaseInterval = setInterval(() => {
                // Turn off previous LED
                const prevIndex = (currentLedIndex - 1 + chaseSequence.length) % chaseSequence.length;
                setLED(chaseSequence[prevIndex], OFF, 0);
                
                // Turn on current LED
                setLED(chaseSequence[currentLedIndex], GREEN, 1);
                
                // Move to next LED
                currentLedIndex = (currentLedIndex + 1) % chaseSequence.length;
            }, CHASE_SPEED);
        };

        // Function to stop LED chase
        window.stopChase = function() {
            if (chaseInterval) {
                clearInterval(chaseInterval);
                chaseInterval = null;
                
                // Turn all LEDs off
                chaseSequence.forEach(name => {
                    setLED(name, OFF, 0);
                });
            }
        };

        // Start the chase effect
        window.startChase();

        // Start the animation loop
        animate();
    </script>
</body>
</html> 