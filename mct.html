<!DOCTYPE html>
<html>
<head>
    <title>MCT Viewer</title>
    <style>
        body { 
            margin: 0; 
            position: relative; 
            background: black; 
            overflow: hidden;
        }
        canvas { 
            width: 100%; 
            height: 100%; 
            position: absolute;
            z-index: 2;
            background: transparent;
        }
        #smoke-background {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 100vh;
            border: none;
            pointer-events: none;
            z-index: 1;
            background: black;
            transform: translate(-50%, -50%);
            display: none;  /* Hide smoke by default */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            pointer-events: none;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 3;
        }
        #togglesDiv {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 3;
            display: none;  /* Hide controls by default */
        }
        #coordsDiv {
            display: none;  /* Hide coordinates by default */
        }
        .toggle-container {
            margin-bottom: 10px;
        }
        .toggle-button {
            background: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .toggle-button.active {
            background: #0f0;
            color: #000;
        }
        .intensity-slider {
            width: 100%;
            margin-top: 5px;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/loaders/STLLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/STLLoader.js"
        }
    }
    </script>
</head>
<body>
    <iframe id="smoke-background" src="smoke.html"></iframe>
    <div id="info"></div>
    <div id="togglesDiv"></div>
    <div id="coordsDiv"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
        import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';

        // Define key surface mappings
        const keySurfaces = {
            'f': [55966, 55967, 55968, 55969],  // F key surfaces
            'u': [55966, 55967, 55968],         // U key surfaces
            'k': [61550, 61551, 61552],         // K key surfaces
            'd': [61550, 61551, 61552, 61553]   // D key surfaces
        };

        // Define button positions
        const buttonPositions = {
            'f': { x: 0.000, y: -1.000, z: 0.500 },
            'u': { x: 0.000, y: 15.000, z: 2.000 },
            'k': { x: 0.000, y: -1.000, z: 0.500 },
            'd': { x: 0.000, y: -15.000, z: 2.000 }
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = null;  // Keep background transparent

        // Camera setup
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 0, 100);  // Position camera directly in front
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            premultipliedAlpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        renderer.sortObjects = true;
        document.body.appendChild(renderer.domElement);

        // Orbit controls setup
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.minDistance = 50;
        orbitControls.maxDistance = 300;
        orbitControls.maxPolarAngle = Math.PI / 1.5;
        orbitControls.minPolarAngle = Math.PI / 6;
        orbitControls.target.set(0, 0, 0);

        // Lighting setup
        const lights = {
            ambient: new THREE.AmbientLight(0xffffff, 2.0),
            key: new THREE.SpotLight(0xffffff, 12.0),
            lowKey: new THREE.SpotLight(0xffffff, 8.0),
            rim: new THREE.DirectionalLight(0xffffff, 8.0),
            left: new THREE.SpotLight(0xffffff, 8.0),
            right: new THREE.SpotLight(0xffffff, 8.0)
        };

        // Add lights to scene
        scene.add(lights.ambient);

        // Configure key light
        lights.key.position.set(0, 100, 300);
        lights.key.target.position.set(0, 0, 0);
        lights.key.angle = Math.PI / 4;
        lights.key.penumbra = 0.3;
        lights.key.decay = 1;
        lights.key.distance = 1000;
        scene.add(lights.key);
        scene.add(lights.key.target);

        // Configure low key light
        lights.lowKey.position.set(0, -100, 300);
        lights.lowKey.target.position.set(0, 0, 0);
        lights.lowKey.angle = Math.PI / 4;
        lights.lowKey.penumbra = 0.3;
        lights.lowKey.decay = 1;
        lights.lowKey.distance = 1000;
        scene.add(lights.lowKey);
        scene.add(lights.lowKey.target);

        // Configure rim light
        lights.rim.position.set(0, 0, 200);
        lights.rim.visible = false;  // Set rim light off by default
        scene.add(lights.rim);

        // Configure left light
        lights.left.position.set(-200, 0, 100);
        lights.left.target.position.set(0, 0, 0);
        lights.left.angle = Math.PI / 4;
        lights.left.penumbra = 0.3;
        lights.left.decay = 1;
        lights.left.distance = 1000;
        scene.add(lights.left);
        scene.add(lights.left.target);

        // Configure right light
        lights.right.position.set(200, 0, 100);
        lights.right.target.position.set(0, 0, 0);
        lights.right.angle = Math.PI / 4;
        lights.right.penumbra = 0.3;
        lights.right.decay = 1;
        lights.right.distance = 1000;
        scene.add(lights.right);
        scene.add(lights.right.target);

        // Create rotating group
        const rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);

        // Create starfield with higher intensity for reflections
        const starfield = createStarfield();
        starfield.renderOrder = -1;
        scene.add(starfield);

        // Create environment map from starfield
        const envMap = createStarfieldEnvMap(renderer, scene, starfield);

        // Mouse and raycaster setup
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let mctMesh = null;
        let hoveredFace = null;

        // Add XYZ axes with hash marks
        const createAxisWithHashes = () => {
            const axisGroup = new THREE.Group();
            
            // Main axes
            const axesHelper = new THREE.AxesHelper(50);
            axesHelper.setColors(
                new THREE.Color(0xff0000), // X axis - red
                new THREE.Color(0x00ff00), // Y axis - green
                new THREE.Color(0x0000ff)  // Z axis - blue
            );
            axisGroup.add(axesHelper);

            // Create hash marks every 10 units
            const hashMarkLength = 2;
            const hashMarkMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

            // Function to create hash marks for each axis
            const createHashMarks = (axis) => {
                for (let i = 10; i <= 50; i += 10) {
                    const hashGeometry = new THREE.BufferGeometry();
                    let vertices;
                    
                    switch(axis) {
                        case 'x':
                            vertices = new Float32Array([
                                i, -hashMarkLength, 0,
                                i, hashMarkLength, 0,
                                i, 0, -hashMarkLength,
                                i, 0, hashMarkLength
                            ]);
                            break;
                        case 'y':
                            vertices = new Float32Array([
                                -hashMarkLength, i, 0,
                                hashMarkLength, i, 0,
                                0, i, -hashMarkLength,
                                0, i, hashMarkLength
                            ]);
                            break;
                        case 'z':
                            vertices = new Float32Array([
                                -hashMarkLength, 0, i,
                                hashMarkLength, 0, i,
                                0, -hashMarkLength, i,
                                0, hashMarkLength, i
                            ]);
                            break;
                    }
                    
                    hashGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    const hashMark = new THREE.LineSegments(hashGeometry, hashMarkMaterial);
                    axisGroup.add(hashMark);
                }
            };

            // Add hash marks to each axis
            createHashMarks('x');
            createHashMarks('y');
            createHashMarks('z');

            return axisGroup;
        };

        // Create axis group but don't add to scene yet
        const axisGroup = createAxisWithHashes();
        axisGroup.visible = false;

        // Add axis labels
        const createAxisLabel = (text, position, color) => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = color;
            context.font = 'bold 48px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(5, 5, 5);
            return sprite;
        };

        // Add number labels at hash marks
        const createNumberLabel = (number, position, color) => {
            const sprite = createAxisLabel(number.toString(), position, color);
            sprite.scale.set(2, 2, 2);
            return sprite;
        };

        // Add number labels every 10 units on each axis
        const axisLabels = new THREE.Group();
        for (let i = 10; i <= 50; i += 10) {
            axisLabels.add(createNumberLabel(i, new THREE.Vector3(i, -3, 0), '#ff0000')); // X axis
            axisLabels.add(createNumberLabel(i, new THREE.Vector3(-3, i, 0), '#00ff00')); // Y axis
            axisLabels.add(createNumberLabel(i, new THREE.Vector3(0, -3, i), '#0000ff')); // Z axis
        }

        const xLabel = createAxisLabel('X', new THREE.Vector3(55, 0, 0), '#ff0000');
        const yLabel = createAxisLabel('Y', new THREE.Vector3(0, 55, 0), '#00ff00');
        const zLabel = createAxisLabel('Z', new THREE.Vector3(0, 0, 55), '#0000ff');
        axisLabels.add(xLabel);
        axisLabels.add(yLabel);
        axisLabels.add(zLabel);
        
        axisLabels.visible = false;
        axisGroup.add(axisLabels);
        scene.add(axisGroup);

        // Create a canvas texture for the 80x160 pixel grid
        const createPixelGridTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 80;
            canvas.height = 160;
            const ctx = canvas.getContext('2d');
            
            // Fill background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 80, 160);
            
            // Draw grid
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 0.5;
            
            // Draw vertical lines
            for (let x = 0; x <= 80; x += 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 160);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= 160; y += 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(80, y);
                ctx.stroke();
            }

            // Add pixel coordinates at corners
            ctx.fillStyle = '#00ff00';
            ctx.font = '8px monospace';
            ctx.fillText('0,0', 2, 8);
            ctx.fillText('80,0', 50, 8);
            ctx.fillText('0,160', 2, 158);
            ctx.fillText('80,160', 50, 158);
            
            return new THREE.CanvasTexture(canvas);
        };

        // Screen rectangle setup
        let screenWidth = 6.2;  // Physical width
        let screenHeight = 11.5;  // Physical height to maintain aspect ratio of 80x160
        const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
        const texture = createPixelGridTexture();
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        
        const screenMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide,
            map: texture
        });

        const screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
        screenMesh.position.set(0.1, 3.2, 9.5);  // Keep existing position
        scene.add(screenMesh);  // Add screen to scene immediately

        // Create coordinates div
        const coordsDiv = document.createElement('div');
        coordsDiv.id = 'coordinates';
        coordsDiv.style.position = 'absolute';
        coordsDiv.style.top = '10px';
        coordsDiv.style.left = '10px';
        coordsDiv.style.color = '#00ff00';
        coordsDiv.style.fontFamily = 'monospace';
        coordsDiv.style.whiteSpace = 'pre';
        coordsDiv.style.display = 'none';  // Hide by default
        document.body.appendChild(coordsDiv);

        // Get the toggles div that's already in the HTML
        const togglesDiv = document.getElementById('togglesDiv');

        // Create light controls
        const lightControls = {
            key: createLightControl('Key Light', lights.key, 12.0),
            lowKey: createLightControl('Low Key', lights.lowKey, 8.0),
            rim: createLightControl('Rim Light', lights.rim, 8.0),
            left: createLightControl('Left Light', lights.left, 8.0),
            right: createLightControl('Right Light', lights.right, 8.0)
        };

        // Add controls to toggles div
        Object.values(lightControls).forEach(control => {
            togglesDiv.appendChild(control);
        });

        // Create coordinates toggle in controls panel
        const coordsControl = document.createElement('div');
        coordsControl.className = 'toggle-container';
        coordsControl.style.borderTop = '1px solid #666';
        coordsControl.style.marginTop = '10px';
        coordsControl.style.paddingTop = '10px';

        const coordsButton = document.createElement('button');
        coordsButton.className = 'toggle-button';  // Start inactive
        coordsButton.textContent = 'Show Coordinates';
        coordsButton.addEventListener('click', () => {
            coordsButton.classList.toggle('active');
            coordsDiv.style.display = coordsButton.classList.contains('active') ? 'block' : 'none';
        });

        coordsControl.appendChild(coordsButton);
        togglesDiv.appendChild(coordsControl);

        // Update the keydown handler for 'c' key to also update button state
        window.addEventListener('keydown', function(event) {
            if (event.key.toLowerCase() === 'c') {
                coordsDiv.style.display = coordsDiv.style.display === 'none' ? 'block' : 'none';
                coordsButton.classList.toggle('active', coordsDiv.style.display === 'block');
            }
        });

        // Materials for different states
        const mctMaterial = new THREE.MeshPhongMaterial({
            color: 0x333333,
            specular: 0x444444,
            shininess: 30,
            side: THREE.DoubleSide,
            transparent: false,
            opacity: 1.0
        });

        // Materials for overlays with improved visibility
        const overlayMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: true,
            polygonOffset: true,
            polygonOffsetFactor: -4
        });

        // Add shader code for plasma effect
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            // Noise functions
            float rand(vec2 n) { 
                return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 ip = floor(p);
                vec2 u = fract(p);
                u = u*u*(3.0-2.0*u);
                
                float res = mix(
                    mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                    mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);
                return res*res;
            }

            void main() {
                // Create plasma effect
                float n = noise(vUv * 5.0 + time * 0.2);
                float n2 = noise(vUv * 10.0 - time * 0.1);
                
                // Create color gradients
                vec3 baseBlue = vec3(0.0, 0.2, 0.8);
                vec3 purple = vec3(0.5, 0.0, 0.8);
                vec3 brightBlue = vec3(0.0, 0.4, 1.0);
                
                // Mix colors based on noise
                vec3 color = mix(baseBlue, purple, n);
                color = mix(color, brightBlue, n2 * 0.5);
                
                // Add fresnel effect for edge glow
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), 2.0);
                color += vec3(0.2, 0.0, 0.4) * fresnel;
                
                // Add pulsing glow
                float pulse = sin(time) * 0.5 + 0.5;
                color += vec3(0.1, 0.0, 0.2) * pulse;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Create plasma material
        const plasmaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.DoubleSide
        });

        // Function to create overlay geometry with improved error handling and visibility
        function createOverlay(geometry, surfaceIds, material, heightOffset) {
            console.log('Creating overlay with surfaces:', surfaceIds);
            try {
                const overlayGeometry = new THREE.BufferGeometry();
                const positions = [];
                const indices = [];
                let vertexCount = 0;

                if (!geometry.attributes.position) {
                    console.error('Geometry has no position attribute');
                    return null;
                }

                const basePositions = geometry.attributes.position.array;
                for (let i = 0; i < basePositions.length; i += 9) {
                    const faceIndex = Math.floor(i / 9);
                    if (surfaceIds.includes(faceIndex)) {
                        console.log('Found matching surface:', faceIndex);
                        for (let j = 0; j < 9; j += 3) {
                            positions.push(
                                basePositions[i + j],
                                basePositions[i + j + 1],
                                basePositions[i + j + 2] + (heightOffset || 0.1)
                            );
                            indices.push(vertexCount++);
                        }
                    }
                }

                if (positions.length === 0) {
                    console.warn('No positions generated for overlay');
                    return null;
                }

                console.log(`Created overlay with ${positions.length / 3} vertices`);
                overlayGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                overlayGeometry.setIndex(indices);
                overlayGeometry.computeVertexNormals();

                const mesh = new THREE.Mesh(overlayGeometry, material || overlayMaterial.clone());
                mesh.renderOrder = 999;
                return mesh;
            } catch (error) {
                console.error('Error in createOverlay:', error);
                return null;
            }
        }

        // Create highlight overlays group
        const highlightOverlays = new THREE.Group();
        scene.add(highlightOverlays);

        // Create STL loader with error handling
        const loader = new STLLoader();

        // Move elements into rotating group
        rotatingGroup.add(mctMesh);
        rotatingGroup.add(highlightOverlays);
        rotatingGroup.add(screenMesh);

        // Add rotation controls (single declaration)
        const rotationControls = {
            enabled: true,      // Start enabled
            speed: 0.2,        // Slower default speed
            angle: 0,          // Start at 0
            maxAngle: Math.PI / 6,  // 30 degrees
            direction: 1,      // Start moving right
            startAngle: 0      // Forward position
        };

        // Update animate function to handle both rotation and starfield
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            updateCoordinates();

            // Handle rotation
            if (rotationControls.enabled) {
                // Update angle
                rotationControls.angle += rotationControls.direction * rotationControls.speed * 0.01;
                
                // Check bounds and reverse direction
                if (Math.abs(rotationControls.angle) >= rotationControls.maxAngle) {
                    rotationControls.direction *= -1;  // Reverse direction
                    // Clamp angle to max to prevent overshooting
                    rotationControls.angle = rotationControls.maxAngle * Math.sign(rotationControls.angle);
                }
                
                // Apply rotation from start position
                rotatingGroup.rotation.y = rotationControls.startAngle + rotationControls.angle;
            }

            // Update starfield rotation
            if (starfield && starfield.visible) {
                starfield.rotation.y += 0.0001;
                starfield.rotation.x += 0.0001;
            }

            renderer.render(scene, camera);
        }

        // Function to update coordinates display
        function updateCoordinates() {
            if (coordsDiv.style.display === 'none') return;
            
            const screenPos = screenMesh.position;
            let coordsText = `Screen: (${screenPos.x.toFixed(2)}, ${screenPos.y.toFixed(2)}, ${screenPos.z.toFixed(2)})<br>` +
                           `Size: ${screenWidth.toFixed(1)} x ${screenHeight.toFixed(1)}`;
            
            // Add positions for all button overlays
            const buttons = ['f', 'u', 'k', 'd'];
            buttons.forEach(key => {
                const overlay = key === 'f' ? 
                    highlightOverlays.userData.fOverlay : 
                    highlightOverlays.userData[`${key}Overlay`];
                    
                if (overlay) {
                    const pos = overlay.position;
                    coordsText += `<br>${key.toUpperCase()} Key Position: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`;
                }
            });
            
            coordsDiv.innerHTML = coordsText;
        }

        // Update the model loading section with reflective material
        loader.load(
            'MCT.stl',
            function(geometry) {
                console.log('STL loaded successfully, processing geometry...');
                
                geometry.center();
                geometry.computeVertexNormals();
                geometry.computeBoundingBox();
                geometry.computeTangents();
                
                const scale = 0.5;
                geometry.scale(scale, scale, scale);
                
                // Create the base mesh with reflective glossy black material
                console.log('Creating base mesh with reflective glossy black material...');
                const glossyBlackMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x000000,           // Pure black
                    metalness: 0.9,            // Very metallic
                    roughness: 0.1,            // Very smooth
                    envMapIntensity: 1.0,      // Full environment map intensity
                    clearcoat: 1.0,            // Add clearcoat
                    clearcoatRoughness: 0.1,   // Smooth clearcoat
                    side: THREE.DoubleSide
                });

                mctMesh = new THREE.Mesh(geometry, glossyBlackMaterial);
                mctMesh.rotation.x = -Math.PI / 2;
                mctMesh.renderOrder = 1;
                mctMesh.castShadow = true;
                mctMesh.receiveShadow = true;
                rotatingGroup.add(mctMesh);

                // Create and apply environment map
                const envMap = createStarfieldEnvMap(renderer, scene, starfield);
                glossyBlackMaterial.envMap = envMap;
                
                // Detailed geometry info
                console.log('Geometry details:', {
                    hasIndex: !!geometry.index,
                    hasPosition: !!geometry.attributes.position,
                    numVertices: geometry.attributes.position.count,
                    numFaces: geometry.attributes.position.array.length / 9,
                    boundingBox: geometry.boundingBox,
                    boundingSphere: geometry.boundingSphere
                });

                // Create F button overlay with improved visibility
                console.log('Creating F key overlay...');
                const fOverlay = createOverlay(geometry, keySurfaces['f'], overlayMaterial.clone(), 0.1);
                if (fOverlay) {
                    fOverlay.rotation.x = -Math.PI / 2;
                    fOverlay.position.copy(buttonPositions['f']);
                    fOverlay.renderOrder = 999;
                    fOverlay.visible = false;  // Hide by default
                    highlightOverlays.userData.fOverlay = fOverlay;
                    highlightOverlays.add(fOverlay);
                    console.log('F overlay created successfully');
                }

                // Create axes helper
                const axesHelper = new THREE.AxesHelper(5);
                axesHelper.visible = false;
                scene.add(axesHelper);

                // Add axes toggle to controls
                const axesDiv = document.createElement('div');
                axesDiv.className = 'toggle-container';
                const axesLabel = document.createElement('label');
                axesLabel.textContent = 'Axes: ';
                const axesButton = document.createElement('button');
                axesButton.textContent = 'Show';
                axesButton.onclick = function() {
                    axesHelper.visible = !axesHelper.visible;
                    axesButton.textContent = axesHelper.visible ? 'Hide' : 'Show';
                };
                axesDiv.appendChild(axesLabel);
                axesDiv.appendChild(axesButton);
                togglesDiv.appendChild(axesDiv);

                // Create other key overlays with improved visibility
                for (const [key, surfaces] of Object.entries(keySurfaces)) {
                    if (key !== 'f') {  // Skip F key (already created)
                        console.log(`Creating overlay for ${key}:`, {
                            numSurfaces: surfaces.length,
                            surfaces: surfaces,
                            position: buttonPositions[key]
                        });
                        const overlay = createOverlay(geometry, surfaces, overlayMaterial.clone(), 0.1);
                        if (overlay) {
                            overlay.rotation.x = -Math.PI / 2;
                            overlay.position.copy(buttonPositions[key]);
                            overlay.renderOrder = 999;
                            overlay.visible = false;
                            overlay.userData.key = key;
                            highlightOverlays.userData[`${key}Overlay`] = overlay;
                            highlightOverlays.add(overlay);
                            console.log(`Successfully created and configured overlay for key: ${key}`);
                        }
                    }
                }
                
                // Move screen and overlays into rotating group
                rotatingGroup.add(screenMesh);
                rotatingGroup.add(highlightOverlays);
                
                // Update camera and controls
                orbitControls.target.copy(rotatingGroup.position);
                camera.lookAt(rotatingGroup.position);
                
                console.log('Model setup complete');
                
                // Reset camera and controls to front view
                camera.position.set(0, 0, 100);
                camera.lookAt(0, 0, 0);
                orbitControls.target.set(0, 0, 0);
                orbitControls.update();
                
                // Ensure rotating group starts at 0
                rotatingGroup.rotation.y = 0;
            },
            function(xhr) {
                // Progress callback
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function(error) {
                // Error callback
                console.error('Error loading STL:', error);
            }
        );

        // Update highlighting function to use overlays
        function highlightSurfacesForKey(key) {
            highlightOverlays.children.forEach(overlay => {
                if (overlay.userData.key) {
                    overlay.visible = overlay.userData.key === key;
                }
            });
        }

        // Materials for highlighting
        const highlightMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.7
        });

        const fKeyMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.7
        });

        // Keep track of original face materials
        const originalFaceMaterials = new Map();
        let activeKey = null;

        // Update the keydown handler
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            const infoDiv = document.getElementById('info');
            
            if (keySurfaces[key]) {
                const surfaceIds = Array.from(keySurfaces[key]).join(', ');
                infoDiv.textContent = `Active Key: ${key}, Surface IDs: ${surfaceIds}`;
                infoDiv.style.display = 'block';
                
                // Show the appropriate overlay
                const overlay = key === 'f' ? 
                    highlightOverlays.userData.fOverlay : 
                    highlightOverlays.userData[`${key}Overlay`];
                    
                if (overlay) {
                    overlay.visible = true;
                }
            }
        });

        // Update the keyup handler
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            const infoDiv = document.getElementById('info');
            
            // Hide overlays and info
            infoDiv.textContent = '';
            infoDiv.style.display = 'none';
            
            // Hide the appropriate overlay
            const overlay = key === 'f' ? 
                highlightOverlays.userData.fOverlay : 
                highlightOverlays.userData[`${key}Overlay`];
                
            if (overlay) {
                overlay.visible = false;
            }
            
            if (key === activeKey) {
                activeKey = null;
            }
        });

        // Dragging state
        let selectedLight = null;
        const dragPlane = new THREE.Plane();
        const intersection = new THREE.Vector3();
        const offset = new THREE.Vector3();
        const dragStart = new THREE.Vector3();

        // Wait for DOM to be loaded before setting up toggles
        document.addEventListener('DOMContentLoaded', () => {
            setupToggle('keyToggle', (active) => {
                lights.key.visible = active;
            });

            setupToggle('rimToggle', (active) => {
                lights.rim.visible = active;
            });

            setupToggle('lowKeyToggle', (active) => {
                lights.lowKey.visible = active;
            });

            setupToggle('axesToggle', (active) => {
                axisGroup.visible = active;
                axisLabels.visible = active;
            });
        });

        // Create rotation control UI
        const rotationDiv = document.createElement('div');
        rotationDiv.className = 'toggle-container';
        rotationDiv.style.borderTop = '1px solid #666';
        rotationDiv.style.marginTop = '10px';
        rotationDiv.style.paddingTop = '10px';

        // Rotation toggle button
        const rotateButton = document.createElement('button');
        rotateButton.className = 'toggle-button active';  // Start active
        rotateButton.textContent = 'Rotate ±30°';
        rotateButton.addEventListener('click', () => {
            rotateButton.classList.toggle('active');
            rotationControls.enabled = rotateButton.classList.contains('active');
            if (!rotationControls.enabled) {
                // Reset to forward position when stopping
                rotationControls.angle = 0;
                rotationControls.direction = 1;
                rotatingGroup.rotation.y = rotationControls.startAngle;
            }
        });

        // Rotation speed slider with slower default
        const speedSlider = document.createElement('input');
        speedSlider.type = 'range';
        speedSlider.className = 'intensity-slider';
        speedSlider.min = '0.1';
        speedSlider.max = '2.0';
        speedSlider.step = '0.1';
        speedSlider.value = '0.2';  // Set to slower default speed
        speedSlider.addEventListener('input', () => {
            rotationControls.speed = parseFloat(speedSlider.value);
        });

        // Add rotation controls to toggles div
        rotationDiv.appendChild(rotateButton);
        rotationDiv.appendChild(speedSlider);
        togglesDiv.appendChild(rotationDiv);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Toggle handlers
        function setupToggle(id, callback) {
            const toggle = document.getElementById(id);
            if (toggle) {
                toggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    callback(this.classList.contains('active'));
                });
            }
        }

        // Remove unused variables and code
        let sourceVisible = false;

        function updateHighlightIntensity() {
            if (hoveredFace !== null) {
                const totalIntensity = controls.keyIntensity + 
                                     controls.lowKeyIntensity + controls.rimIntensity;
                highlightMaterial.emissiveIntensity = Math.min(totalIntensity * 0.3, 1.0);
            }
        }

        // Add keyboard controls for screen position
        window.addEventListener('keydown', function(event) {
            if (!screenMesh) return;
            
            const normalSpeed = 1;
            const fineSpeed = 0.1;
            const moveSpeed = event.shiftKey ? fineSpeed : normalSpeed;
            
            switch(event.key) {
                case 'ArrowLeft':
                    screenMesh.position.x -= moveSpeed;
                    break;
                case 'ArrowRight':
                    screenMesh.position.x += moveSpeed;
                    break;
                case 'ArrowUp':
                    screenMesh.position.y += moveSpeed;
                    break;
                case 'ArrowDown':
                    screenMesh.position.y -= moveSpeed;
                    break;
                case 'PageUp':
                    screenMesh.position.z += moveSpeed;
                    break;
                case 'PageDown':
                    screenMesh.position.z -= moveSpeed;
                    break;
            }
            screenMesh.updateMatrix();
        });

        // Function to create a toggle container with intensity slider
        function createLightControl(label, light, initialIntensity) {
            const container = document.createElement('div');
            container.className = 'toggle-container';
            
            // Create toggle button
            const button = document.createElement('button');
            button.className = 'toggle-button active';
            button.textContent = label;
            button.addEventListener('click', () => {
                button.classList.toggle('active');
                light.visible = button.classList.contains('active');
            });
            
            // Create intensity slider
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.className = 'intensity-slider';
            slider.min = '0';
            slider.max = '20';
            slider.step = '0.1';
            slider.value = initialIntensity;
            slider.addEventListener('input', () => {
                light.intensity = parseFloat(slider.value);
            });
            
            container.appendChild(button);
            container.appendChild(slider);
            return container;
        }

        // Create starfield with higher intensity for reflections
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,             // Increased size
                transparent: true,
                opacity: 1.0,        // Full opacity
                sizeAttenuation: false
            });

            const starVertices = [];
            for (let i = 0; i < 3000; i++) {  // More stars
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            return stars;
        }

        // Create environment map from starfield
        function createStarfieldEnvMap(renderer, scene, stars) {
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512);
            const cubeCamera = new THREE.CubeCamera(1, 100000, cubeRenderTarget);
            scene.add(cubeCamera);
            
            // Update the environment map
            function updateEnvMap() {
                if (stars.visible) {
                    // Temporarily hide the model and other objects
                    const visibleObjects = scene.children.filter(obj => obj.visible && obj !== stars);
                    visibleObjects.forEach(obj => obj.visible = false);
                    
                    // Update the environment map
                    cubeCamera.update(renderer, scene);
                    
                    // Restore visibility
                    visibleObjects.forEach(obj => obj.visible = true);
                }
                requestAnimationFrame(updateEnvMap);
            }
            updateEnvMap();
            
            return cubeRenderTarget.texture;
        }

        // Add background effect controls
        const bgControl = document.createElement('div');
        bgControl.className = 'toggle-container';
        bgControl.style.borderTop = '1px solid #666';
        bgControl.style.marginTop = '10px';
        bgControl.style.paddingTop = '10px';

        // Starfield toggle
        const starfieldButton = document.createElement('button');
        starfieldButton.className = 'toggle-button active';  // Start active
        starfieldButton.textContent = 'Starfield';
        starfieldButton.addEventListener('click', () => {
            starfieldButton.classList.toggle('active');
            starfield.visible = starfieldButton.classList.contains('active');
        });

        // Smoke toggle
        const smokeButton = document.createElement('button');
        smokeButton.className = 'toggle-button';  // Start inactive
        smokeButton.textContent = 'Smoke Effect';
        const smokeBackground = document.getElementById('smoke-background');
        smokeButton.addEventListener('click', () => {
            smokeButton.classList.toggle('active');
            smokeBackground.style.display = smokeButton.classList.contains('active') ? 'block' : 'none';
        });

        // Add background controls to toggles div
        bgControl.appendChild(starfieldButton);
        bgControl.appendChild(smokeButton);
        togglesDiv.appendChild(bgControl);

        // Add 't' key handler for toggle controls
        window.addEventListener('keydown', function(event) {
            if (event.key.toLowerCase() === 't') {
                const togglesDiv = document.getElementById('togglesDiv');
                togglesDiv.style.display = togglesDiv.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Start the animation loop
        animate();
    </script>
</body>
</html> 